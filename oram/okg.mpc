from rdflib import Graph
from rdflib.extras.external_graph_libs import rdflib_to_networkx_multidigraph
import networkx as nx
import numpy as np
import sys
sys.path.append("../")
from oram_utils import string_to_int, int_to_string
from Compiler.circuit_oram import OptimalORAM

class ObliviousGraph(Graph):

    """
    Pass in an already parsed RDF Graph as given by Graph.parse in RDFLib
    """
    def __init__(self, rdf_graph):
        self._rdf_graph = rdf_graph
        self._networkx_graph = rdflib_to_networkx_multidigraph(rdf_graph, edge_attrs=lambda s,p,o : {"weights": string_to_int(p)}, transform_s=string_to_int,transform_o=string_to_int)
        self._adjacency_matrix_weights = nx.to_pandas_adjacency(self._networkx_graph).values
        self.kg_oram = OptimalORAM(len(self._networkx_graph.nodes())**2)
        self.nodes = OptimalORAM(len(self._networkx_graph.nodes()))
        self.nodes[0] = tuple(nx.to_pandas_adjacency(self._networkx_graph).index.tolist())

        # Generate Oblivious Adjacency Matrix
        self._adjacency_matrix = nx.adjacency_matrix(self._networkx_graph)
        self.size_of_obj_adj_matrix = self._adjacency_matrix.shape[0]
        self.obv_adj_matrix = OptimalORAM(size=self.size_of_obj_adj_matrix)
        for i in range(self.size_of_obj_adj_matrix):
            #row = self._adjacency_matrix.getrow(i).toarray().tolist()
            self.obv_adj_matrix[i] = tuple(self._adjacency_matrix.getrow(i).toarray().tolist()[0])
            self.kg_oram[i] = tuple(self._adjacency_matrix_weights[i].astype(np.int64).tolist())

    def _get_selection_matrix(self, predicate):
        selection_matrix = OptimalORAM(self.size_of_obj_adj_matrix)
        for i in range(self.size_of_obj_adj_matrix):
            for j in range(self.size_of_obj_adj_matrix):
                if i == j:
                    selection_matrix[i][i] = predicate
                else:
                    selection_matrix[i][j] = 0
        return selection_matrix

    """
    Does a matrix multiplication with 2 oram-based matrices.
    NB: Currently implements a naive matrix multiplication algorithm. Should implement something like Strassen's algorithm for speed
    """
    def _matrix_multiplication(self, oram_matrix1, oram_matrix2):
        assert oram_matrix1.oram.size == oram_matrix2.oram.size
        size = oram_matrix1.oram.size
        res = OptimalORAM(size)
        for i in range(size):
            for j in range(size):
                if i == j:
                    res[i][j] = oram_matrix1[i][j] * oram_matrix2[i][j]
                else:
                    res[i][j] = 0
        
        return res

    """
    Does a matrix multiplication with the LOR.iseq semiring as specified in section 3.2
    """
    def _semiring_matrix_multiplication(self, oram_matrix1, oram_matrix2):
        assert oram_matrix1.oram.size == oram_matrix2.oram.size
        size = oram_matrix1.oram.size
        res = OptimalORAM(size)
        for i in range(size):
            for j in range(size):
                if oram_matrix1[i][j] == oram_matrix2[i][j]:
                    res[i][j] = 1
                else:
                    res[i][j] = 0
        return 0

    def _any(self, oram_matrix):
        pass

    """
    For a given predicate, get all pairs of (subject, objects) that have that predicate as their edge label
    """
    def get_all_pairs(self, predicate):
        pairs = []
        selection_matrix = self._get_selection_matrix(predicate)
        binding_matrix = self._semiring_matrix_multiplication(selection_matrix, self.kg_oram)
        for i in range(binding_matrix.oram.size):
            for j in range(binding_matrix.oram.size):
                if binding_matrix[i][j] == 1:
                    pairs.append([self.nodes[i], self.nodes[j]])
        return pairs

g = Graph()
g.parse("http://www.w3.org/People/Berners-Lee/card")
obv_graph = ObliviousGraph(g)